---
title: 'Kickstarter. Análisis de proyectos de crowfunding'
author: "Adam Kepa"
date: "28 de mayo de 2019"
output:
  html_document:
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 3
    toc_float: true
    params: 
      output_dir: "../pdf"
  word_document: default
  pdf_document:
    highlight: zenburn
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval=T, echo=T)
library(dplyr)
library(janitor)
library(randomForest)
library(ggplot2)
library(gmodels)
```

# Introducción
## Descripción del dataset

Para esta práctica se ha elegido el set de datos [Kickstarter Projects](https://www.kaggle.com/kemical/kickstarter-projects) de Kaggle, con datos relativos a iniciativas que buscan financiación en la página [Kickstarter.com](https://www.kickstarter.com/).

Es un set de datos interesantes por el gran volumen de observaciones (más de 300K), y que se asemeja al volumen del que de datos que se puede manejar en proyectos reales de ciencia de datos. Por otro lado, es interesante por ser un set relativamente actual y por las variables disponibles. Éstas son tanto cuantitativas como cualitativas, y alguna de ellas tienen un número alto de categorías.

El listado completo de variables es el siguiente:

1. __ID__. Numérico. Identificador de la iniciativa.
2. __Name__. Categórico. Nombre de la iniciativa.
3. __Main category__. Categórico. Categoría de la iniciativa (nivel 1).
4. __Category__. Categórico. Categoría de la iniciativa (nivel 2).
5. __Currency__. Categórico. Moneda en la que se realiza la recaudación.
6. __Deadline__. Fecha. Fecha en la que acaba la recaudación.
7. __Goal__. Numérico. Cantidad de dinero que se intenta recaudar. 
8. __Launched__. Timestamp. Fecha y hora en la que se inició la iniciativa. 
9. __Pledged__. Numérico. Dinero recaudado al cumplirse la fecha de fin. 
10. __Backers__. Numérico. Número de patrocinadores que han participado en la iniciativa
11. __Country__. Categórico. País de origen de la iniciativa.
12. __USD Pledged__. Numérico. Conversión de la variable _Pledged_ a la divisa USD, realizado por Kickstarter.com
13. __USD Pledged Real__. Numérico. Conversión de la variable _Pledged_ a la divisa USD, realizado por el autor del dataset.
14. __USD Goal Real__. Numérico. Conversión de la variable _Goal_ a la divisa USD, realizado por el autor del dataset.

Este estado final de una iniciativa se indica en el campo state: 

1. __state__. Categórico. Resultado de la iniciativa al finalizar el plazo. 

__El objetivo de este set de datos es intentar predecir el estado final de una iniciativa a partir de los predictores mencionados anteriormente. Para ello, el primer paso (y el problema que trataremos de resolver con esta práctica), es tratar de descubrir si existen diferencias significativas de los predictores asociadas a los distintos estados de los proyectos__.


### Carga de datos

Realizamos la carga de datos. En este caso, y puesto que tenemos variables de tipo fecha, vamos a cargar las variables categóricas como strings para realizar la conversión al tipo esperado a posteriori.

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
path <- "../csv/ks-projects-201801.csv"
original <- read.csv(path, header=T,sep=",", encoding = "UTF-8", stringsAsFactors=FALSE)

glimpse(original)

original$launched <- as.Date(original$launched)
original$deadline <- as.Date(original$deadline)
original$category <- as.factor(original$category)
original$main_category <- as.factor(original$main_category)
original$currency <- as.factor(original$currency)
original$state <- as.factor(original$state)
original$country <- as.factor(original$country)
```

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
glimpse(original)
```

## Selección de datos

En el listado de variables de la sección anterior vemos que el set de datos incluye información duplicada. La cantidad objetivo está disponible en la moneda original de la promoción (_Goal_), así como su conversión a USD (_USD Goal Real_). Por otro lado, la cantidad final recaudada está disponible en la divisa original (_Pledged_), la conversión a USD realizada por la plataforma (_USD Pledged_), y la conversión a USD realizada por el autor del set de datos (_USD Goal Real_). Puesto que la información de estas variables es redundante, se va a mantener únicamente la versión estandarizada de estos datos. Esto es, la conversión de las dos variables realizadas por el autor del set de datos. 

Por otro lado, para realizar la analítica de datos no son necesarios los campos que identifican las observaciones (_ID_ y _Name_).

Finalmente, y puesto que no se va a realizar un análisis de series temporales, se puede descartar las variables de tipo fecha (_Launched_ y _Deadline_). Sin embargo, a partir de estas variables es posible derivar un nuevo campo que podría tener influencia en el resultado de la recaudación de fondos: la duración de la campaña. 

Vamos a derivar este dato, y a elmininar las variables innecesarias. Estas modificaciones se realizarán sobre una copia del set original, por si fuese necesario realizar alguna comprobación sobre este set más adelante. 

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
# Copia del set de datos
mydata <- original
# Derivación de la duración
mydata$duration_tmp <- mydata$deadline - mydata$launched
mydata$duration <- as.numeric(mydata$duration_tmp, units="days")
original$duration <- as.numeric(mydata$duration_tmp, units="days")
# Borrado de las variables innecesarias
mydata <- select(mydata, -ID, -name, -goal, -pledged, -usd.pledged, -launched, -deadline, -duration_tmp)
# Resumen de los datos seleccionados
glimpse(mydata)
```

Como se puede observar en la tabla anterior, se ha reducido el set a ocho inputs y la etiqueta de clase.

# Limpieza de datos
## Valores perdidos

En primer lugar, vamos a comprobar si existen observaciones con el valor NA en alguna variable:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
colSums(is.na(mydata))
```

Vemos que no existen valores sin imputar. Vamos a comprobar también cuales son los posibles valores de las variables de tipo "Factor" para comprobar si los valores nulos se han reemplazado por alguna etiqueta:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
unique(mydata$category)
unique(mydata$main_category)
unique(mydata$currency)
unique(mydata$state)
unique(mydata$country)
```

Vemos que la etiqueta de clase (variable _state_) tiene seis posibles valores entre los que se encuentran "undefined" y "live". El primero se corresponde a una etiqueta que se ha dado a los valores perdidos, y el segundo a campañas que estaban en activo cuando se hizo la recopilación de datos. Las observaciones de este segundo caso no aportan valor para predecir el resultado de una campaña al tratarse de observaciones de campañas no finalizadas, y por tanto habrá que eliminarlas. En cuanto al primer caso, sería posible imputar valores o eliminar también las observaciones asociadas. Para decidir entre una u otra, vamos a comprobar el porcentaje de observaciones de esta clase en una tabla de frecuencias:

```{r echo=TRUE, message=FALSE, warning=FALSE}
tabyl(mydata$state)
```

Las observaciones con estado _"undefined"_ suponen menos del 1% del total. Por ello, y por el hecho de que el número total de observaciones es muy amplio, vamos a eliminar las observaciones asociadas:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
mydata <- subset(mydata, state != "undefined" & state != "live")
# Creamos un factor nuevo para elminar las categorías descartadas
mydata$state <- as.factor(as.character(mydata$state))
# Tabla de frecuencias después del ajuste
tabyl(mydata$state)
```

Por otro lado, vemos que existe un valor anómalo ("N,0\") en la variable country. Este valor probablemente se deba a un error a la hora de hacer el scrapping de los datos. Comprobamos el número de observaciones afectadas:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
nrow(subset(mydata, (country == "N,0\"")))
```

Y procedemos de forma análoga a la anterior: el número de observaciones afectadas es despreciable comparado con el total, y por tanto se pueden descartar sin problemas:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
mydata <- subset(mydata, (country != "N,0\""))
# Creamos un factor nuevo para elminar la categoría incorrecta
mydata$country <- as.factor(as.character(mydata$country))
```

Para el resto de variables cualitativas no se observa ningún valor que pueda representar un valor perdido o erróneo. 

## Valores extremos

Vamos a analizar las variables cuantitativas en búsqueda de valores extremos. 

### Patrocinadores (backers)

Esta variable representa al número de patrocinadores que han aportado dinero a la iniciativa.  Vamos a comprobar la distribución de los valores:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
summary(mydata$backers)
par(mfrow=c(1,2))
hist(mydata$backers)
boxplot(mydata$backers)
```

Vemos que existen valores muy extremos. El 75% de los datos (3er cuartil) está por debajo de 57 patrocinadores. Sin embargo, existen valores superiores a 200000. Vamos a comprobar a cuantas iniciativas han contribuído más de 100000 personas:
```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
nrow(subset(mydata, backers > 100000))
```

Comprobamos estas observaciones en el set original:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
subset(original, backers > 100000)
```

Acudiendo a Kickstarter, comprobamos que estos valores son correctos, y que se corresponden a las iniciativas que históricamente han tenido más exito en esta plataforma:

* [Fidget Cube: A Vinyl Desk Toy](https://www.kickstarter.com/projects/antsylabs/fidget-cube-a-vinyl-desk-toy?lang=es)
* [https://www.kickstarter.com/projects/elanlee/exploding-kittens?lang=es](https://www.kickstarter.com/projects/antsylabs/fidget-cube-a-vinyl-desk-toy?lang=es)
* [Bring Reading Rainbow Back for Every Child, Everywhere!](https://www.kickstarter.com/projects/readingrainbow/bring-reading-rainbow-back-for-every-child-everywh?lang=es)

Por tanto, son observaciones legítimas que no se deben descartar. Dada la distribución de valores, la distribución de los datos asemeja una distribución exponencial. Vamos a repetir el análisis aplicado al logaritmo del valor original:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
summary(log(mydata$backers))

par(mfrow=c(1,2))
hist(log(mydata$backers))
#curve(dnorm(x, mean=log(mydata$backers), sd=sd(log(mydata$backers))), col="red", lwd=2, add=TRUE, yaxt="n")
boxplot(log(mydata$backers))
```

El histograma anterior se asemeja a una distribución normal, por lo que podemos asumir que los valore extremos anteriores son 

### Cantidad recaudada (usd_pledged_real)

Esta variable es la candidad de dinero recaudado para poder realizar el proyecto. Vamos a comprobar la distribución de los valores:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
summary(mydata$usd_pledged_real)
par(mfrow=c(1,2))
hist(mydata$usd_pledged_real)
boxplot(mydata$usd_pledged_real)
```

Al igual que en el caso anterior, también existen valore extremos (basta con observar la gran diferencia entre la media, la mediana y el valor máximo). Vamos a extraer las observaciones con los valores más altos de eta variable: 

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
aux <- original[order(-original$usd_pledged_real),]
head(aux, n = 2)
```

Acudiendo a Kickstarter vemos que estos valores extremos son correctos y se corresponden también a proyectos con mucho éxito. 

* [Pebble Time - Awesome Smartwatch](https://www.kickstarter.com/projects/getpebble/pebble-time-awesome-smartwatch-no-compromises?lang=es)
* [COOLEST COOLER](https://www.kickstarter.com/projects/ryangrepper/coolest-cooler-21st-century-cooler-thats-actually?lang=es)

De forma análoga a como se ha procedido anteriormente, vamos a observar como se distribuyen estos valores considerando que se distribuyen de forma exponencial. Aplicamos el logaritmo de los valores:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
summary(log(mydata$usd_pledged_real))

par(mfrow=c(1,2))
hist(log(mydata$usd_pledged_real))
boxplot(log(mydata$usd_pledged_real))
```

Y vemos que éstos se asemejan a una distribucion normal. Bajo esta distribución vemos que siguen existiendo ciertos outliners, pero como hemos visto, éstos se corresponden a los proyectos que mas éxito han tenido en la plataforma. 

### Cantidad objetivo (usd_goal_real)

Esta variable representa la cantidad que tienen como objetivo recaudar los proyectos. Vamos a observar la distribución de los valores:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
summary(mydata$usd_goal_real)

par(mfrow=c(1,2))
hist(mydata$usd_goal_real)
boxplot(mydata$usd_goal_real)
```

De forma análoga a las dos variables anteriores, la distribución se asemeja a una distribución exponencial. Vamos a aplicar la función logaritmo:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
summary(log(mydata$usd_goal_real))

par(mfrow=c(1,2))
hist(log(mydata$usd_goal_real))
boxplot(log(mydata$usd_goal_real))
```

En los gráficos anteriores vemos que, de forma análoga a las variables anteriores, los valores extremos se debían a que los datos no se distribuyen bajo una distribución normal. 

### Duración campaña (duration)
Vamos a comprobar la distribución de valores de la variable derivada al inicio:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
summary(mydata$duration)

par(mfrow=c(1,2))
hist(mydata$duration)
boxplot(mydata$duration)
```

Vemos que en este caso también existen valores muy extremos. El valor máximo son 16739 días (45 años), lo que supone que se trata de un valor erróneo. Vamos a comprobar cuantas iniciativas hay con más 100 días de duración:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
nrow(subset(mydata, duration > 100))
```

Únicamente 7, por lo que probablemente se deba a un error en los datos iniciales o en el cálculo de la variable. Para comprobarlo, vamos a examinar las observaciones asociadas en el set de datos inicial:

```{r echo=TRUE, message=FALSE, warning=FALSE}
subset(original, duration > 100)
```

Vemos que el error se debe a que la fecha de inicio de algunas iniciativas está mal informada (1970-01-01). Se trata del valor inicial del formato [epoch](https://en.wikipedia.org/wiki/Unix_time), por lo que seguramente se trate de valores perdidos. Eliminamos estas observaciones, y volvemos a analizar la distribución de valores:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
# Eliminamos observaciones con valores incorrectos
mydata <- subset(mydata, duration < 100)

summary(mydata$duration)

par(mfrow=c(1,2))
hist(mydata$duration)
boxplot(mydata$duration)
```

Vemos que ahora existen valores extremos, pero correctos: la campaña más larga se situa en torno a los 3 meses, mientras que tanto el valor medio como el mediano están en torno a un mes. La distribución que se observa en el histograma se asemeja a una distribución normal. 

# Análisis de datos

## Análisis de normalidad

Como hemos visto en el apartado anterior, las variables cuantitativas "backers", "usd_pledged_real" y "usd_goal_real" se distribuyen bajo una distribución exponencial, por lo que no es necesario comprobar su normalidad. 

La única variable que se haría falta comprobar es "duration". Para ello, aplicamos el test Shapiro-Wilk, donde planteamos las siguientes hipótesis:

$$H_{0}: \text{La variable se distribuye normalmente}$$ 

$$H_{1}:  \text{La variable NO se distribuye normalmente}$$
Suponemos un nivel de significación del 0.05. 

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
#Hace falta una muestra, porque el tamaño máximo aceptado por el test es de 5000 observaciones. 
set.seed(123)
sample <- mydata[sample(1:nrow(mydata), 5000, replace=FALSE),]
#Test
shapiro.test(as.numeric(sample$duration))
```

El p-value es cercano a 0, por lo que rechazamos la hipótesis nula y aceptamos la alternativa. Esto es, que la variable "duration" no se distribuye de forma normal.  

## Selección de datos

Para seleccionar los datos sobre los que vamos a realizar el análisis, vamos a realizar un análisis previo de correlación para ver si es posible reducir la dimensionalidad descartando algunas de las variables que no son independientes.  

Vamos a proceder en primer lugar con las cuatro variables categóricas disponibles. 

En primer lugar, las variables "Category" y "Main Category" están correlacionadas por definición (la primera es un desglose de la segunda). Para realizar un análisis manual, vamos a quedarnos únicamente con la segunda, puesto que la primera tiene un número de valores posibles demasiado alto para ser manejable en un análisis no automatizado.

Por otro lado, las variables "Country" y "Currency" probablemente sean dependientes. Vamos a realizar un 
test [chi-square](https://en.wikipedia.org/wiki/Chi-squared_test) para verificar si se puede obviar una de ellas en el análisis. Planteamos las hipótesis, y supondremos un nivel de significación del 0.05:

$$H_{0}: \text{Las variables son independientes}$$ 

$$H_{1}:  \text{ Las variables NO son independientes}$$

Calculamos el p-value:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
t <- table(mydata$currency, mydata$country)
chisq.test(t ) 
```

Y vemos que el valor es prácticamente 0, por lo que rechazamos la hipótesis nula y aceptamos la alternativa. Esto es, que las variables no son independientes. Por ello, vamos a excluir la variable "Currency" de los datos a analizar.

Para las variables cuantitativas, vamos a calcular la matrix de correlación usando como método la correlación de Spearman, al no distribuirse las variables de forma normal:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
num_vars = select(mydata, backers, country, usd_pledged_real, usd_goal_real, duration)
round(cor(x = data.matrix(num_vars), method = "spearman"), 3)
```

Vemos que el número de patrocinadores y el dinero recaudado tienen una relación de correlación positiva, por lo que el análisis se realizará únicamente sobre una de las dos.

Eliminamos del set de datos aquellas variables que no tendremos en cuenta para el análisis:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
mydata <- select(mydata, -currency, -category, -backers)
```

Por lo que para el análisis dispondremos de 5 variables, y la etiqueta de clase:
```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
glimpse(mydata)
```


# Representación de resultados

# Conclusión
(Falta completar)

# Referencias y bibliografía
(Falta completar)


